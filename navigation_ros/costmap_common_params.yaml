obstacle_range: 4.0 # Maximum distance upto which obstacles are recorded. 
raytrace_range: 3.5 # This much distance should be free in front of the bot.

footprint: [[0.6, 0.35], [0.6, -0.35], [-0.6, -0.35], [-0.6, 0.35]] # Graphical coordinates of the bot.
footprint_padding: 0.25 # Inflating the bot itself to prevent collision and ensure safe navigation.

map_type: costmap
observation_sources: scan # list of sensors from where we get the data for the map
scan:                     # same name as above
  {
    sensor_frame: base_scan,     # coordinate frame of the sensor 
    data_type: LaserScan,        # datatype for the laser scanner
    topic: scan,                 # topic where data publishes
    marking: true,               # sensor will be used to add obstacle to map or clear from it or do both
    clearing: true,              # same as above
  }

# To actually specify the layers, we store dictionaries in the array of plugins.
# Additional layers can be added with additional dictionaries in the array. 
plugins:
  - { name: static_layer, type: "costmap_2d::StaticLayer" }
  - { name: obstacles_layer, type: "costmap_2d::ObstacleLayer" }
  - { name: inflater_layer, type: "costmap_2d::InflationLayer" }

# static map shows unchanging areas of the map like those generated by SLAM(published by gmapping). 
static_layer:
  map_topic: /map  # cost map subscribes to it(for the static map). Useful when we have to many maps within a single node. 
  subscribe_to_updates: true  # keep on updating (SLAM --> so useful in here)

# Obstacle layer tracks obstacles as read by the sensor data. (Volexplugin is used for 3D)

obstacles_layer:
  # These are sensor management parameters (Only in obstacle layer and not in others)
  observation_sources: laser_scan_sensor # list (namespace) of sensors from where we will be getting the data
  laser_scan_sensor:
    {
      sensor_frame: laser_frame,  
      data_type: LaserScan,
      topic: scan,
      marking: true,
      clearing: true,       # Max range which is declared as free if it is less than raytrace range.
      obstacle_range: 6.0,  # Max range upto which we insert obstacles to the cost map
      raytrace_range: 8.5,  # Max range which is declared as free if it is less than raytrace range. 
                            # Max dist upto which we raytrace out obstacles from the cost map
    }

# Inflation layer we just have these two params
inflater_layer:
  inflation_radius: 2.0 # inflates object to prevent collision
  cost_scaling_factor: 1.0 # ingridient used in calculating cost for each cell in costmap.
                           # As it is multipied by -ve in formula 
                           # so increasing it --------> decreases the cost. 